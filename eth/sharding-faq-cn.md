
https://github.com/ethereum/wiki/wiki/Sharding-FAQs


## 分片介绍

目前，在所有区块链协议中，每个节点存储所有状态（账户余额，合同代码和存储等）并处理所有交易。 这提供了大量的安全性，但极大地限制了可伸缩性：区块链不能处理比单个节点更多的事务。 在很大程度上是因为这个，比特币被限制在每秒约3-7个事务，以太网到7-15等等。但是，这提出了一个问题：有没有办法创建一个新机制，其中只有一小部分节点 验证每笔交易？ 只要有足够多的节点验证每个事务系统仍然是高度安全的，但是总验证器集的百分比足够小，系统可以并行处理许多事务，我们是否可以不使用这种技术来大大增加 区块链的吞吐量？

## 主要内容


* 解决问题的方法有哪些微不足道但有缺陷的方法？
* 这听起来像是有某种可扩展性的三难问题。这是什么三难？我们可以突破它吗？
* 有些人声称，由于梅特卡夫定律，加密货币的市值应该与n ^ 2成比例，而不是n。他们有意义吗？
*  为什么不？
* 有哪些中等简单但只有部分解决可伸缩性问题的方法？
* 那些不试图“粉碎”任何东西的方法呢？
* 等离子，国家通道和其他第2层技术如何适应三难？
* 状态大小，状态历史，密码经济学，哦，我的！在我们继续前进之前定义其中的一些术语！
* 分片背后的基本理念是什么？
* 分片区块链的基本设计可能是什么样的？
* 这里有哪些挑战？
* 但CAP定理是否意味着完全安全的分布式系统是不可能的，因此分片是徒劳的？
* 我们正在运营的安全模型是什么？
* 我们如何在不协调的多数模型中解决单一碎片接管攻击？
* 您如何在工作证明和股权证明中实际进行抽样？
* 如何生成随机抽样的随机性？
* 如何权衡采样的频率？
* 我们是否可以强制更多的状态保持在用户端，以便可以验证事务而无需验证程序保存所有状态数据？
* 我们可以分割数据和执行，以便我们从快速洗牌数据验证中获得安全性，而无需改组执行状态执行的节点的开销吗？
* SNARK和STARK可以提供帮助吗？
* 我们如何促进跨域通信？
* 什么是火车和酒店的问题？
* 在贿赂攻击者或协调选择模型中通过随机抽样进行分片的问题是什么？
* 我们如何才能改进这一点？
* 什么是数据可用性问题，我们如何使用纠删码来解决它？
* 我们是否可以通过某种花哨的加密累加器方案来消除解决数据可用性的需要？
* 所以这意味着我们实际上可以创建可缩放的分片区块链，其中发生任何不良事件的成本与整个验证器集的大小成正比？
 让我们走一点吧。如果我们有即时洗牌，我们真的需要这种复杂性吗？即时重排是否意味着每个分片都直接从全局验证器池中提取验证器，因此它就像区块链一样运行，因此分片实际上不会引入任何新的复杂性？
* 您提到了透明分片。我12岁了，这是什么？
* 这有什么优点和缺点？
* 同步交叉分片消息如何工作？
* 半异步消息怎么样？
* 什么是保证跨分片电话？
* 等等，但是如果攻击者同时从每个分片发送一个交叉分片调用到shard X怎么办？在数学上不可能及时包含所有这些电话吗？
* 凝固气体？这听起来不仅仅是跨分片操作，还有可靠的分片内调度
* 保证调度，包括分片内和交叉分片，是否有助于反对审查交易的多数共谋？
* 分片区块链可以更好地处理网络分区吗？
* 推动缩放超过n = O（c ^ 2）的独特挑战是什么？
* 异构分片怎么样？
* 脚注


## 解决这个问题有哪些微不足道但有缺陷的方法？

“简易解决方案”有三大类。第一个是放弃缩放单个区块链，而是假设用户将使用许多不同的“山寨币”。这大大增加了吞吐量，但是以安全为代价：使用这种方法的吞吐量的N因子增加必然伴随着N因子的安全性降低。因此，对于超过N的小值，它可能是不可行的。

第二个是简单地增加块大小限制。这可以起作用，并且在某些情况下可能是正确的处方，因为块尺寸可能更多地受到政治的约束而不是现实的技术考虑。但无论一个人对任何个案的看法如何，这种方法都不可避免地有其局限性：如果一个人走得太远，那么在消费者硬件上运行的节点将会退出，网络将开始完全依赖于运行区块链的极少数超级计算机，这可能导致巨大的集中风险。

第三种是“合并采矿”，这是一种技术，其中有许多链条，但所有链条共享相同的采矿能力（或者，在股权制度的证明中，股权）。目前，Namecoin通过这样做从比特币区块链中获得了很大一部分安全性。如果所有矿工都参与其中，理论上这可以在不影响安全性的情况下将吞吐量提高N倍。然而，这也存在这样的问题：它将每个矿工的计算和存储负荷增加了N倍，因此实际上这种解决方案只是块大小增加的隐形形式。

即使这被认为是可以接受的，仍然存在链条没有真正“捆绑在一起”的缺陷;只需要少量的经济激励来说服矿工放弃或妥协一条特定的链条。这种可能性实际上是非常真实的，并且已经发生了合并开采链受到攻击的实际历史事件，以及明确提倡使用合并挖掘攻击作为“治理”功能的开发人员，破坏了不“有利可图”的链条。对一个特定的联盟。

如果只有少数矿工/采矿池参与合并挖掘每个产业链，那么集中化的风险即将来临，而合并采矿的安全效益也会大大降低。



## 这听起来像是有某种可扩展性的三难困境。 这是什么三难？我们可以突破它吗？

三难论声称区块链系统最多只能具有以下三个属性中的两个：

*权力下放（定义为系统能够在每个参与者只能访问O（c）资源的情况下运行，即普通笔记本电脑或小型VPS）
*可伸缩性（定义为能够处理O（n）> O（c）事务）
*安全性（定义为对具有高达O（n）资源的攻击者安全）

在本文档的其余部分中，我们将继续使用c来指代每个节点可用的计算资源（包括计算，带宽和存储）的大小，并且n在某种抽象意义上指代生态系统的大小; 我们假设加密货币的交易负荷，州规模和市值都与n成正比。


## 有些人声称，由于梅特卡夫定律，加密货币的市值应该与n ^ 2成比例，而不是n。 他们有意义吗？

没有。


## 为什么没有？

梅特卡夫定律声称网络的价值与用户数的平方成正比（n ^ 2），因为如果一个网络有n个用户，那么网络对每个用户都有价值，但每个用户的价值就是本身与用户数量成正比，因为如果一个网络有n个用户通过网络进行n-1个潜在连接，每个用户都可以从中受益。

在实践中，实证研究表明，对于较大的n值，具有n个用户的网络的值接近于n的小值和n（n×log n）比例的n ^ 2比例。“这是有意义的，因为对于小值这个论点是正确的，但一旦系统变大，两种效应就会减缓增长速度。首先，实践中的增长经常发生在社区中，因此在中等规模的网络中，网络通常已经提供了每个用户关心的大多数连接。其次，连接通常是彼此的替代品，你可以争辩说人们只能从拥有k个连接中获得〜（log（k））值 - 有23个品牌的除臭剂可供选择是好的，但它并没有那么好有22个选择，而一个选择和零选择之间的差异非常显着。

此外，即使加密货币的价值与k用户的O（k * log（k））成比例，如果我们接受上述解释作为原因，那么这也意味着交易量也是O（k * log（k）），因为每个用户的log（k）值理论上来自通过网络行使log（k）连接的用户，并且状态大小在许多情况下也应该随O（k * log（ k））因为至少有某种类型的状态是关系特定的而不是用户特定的。因此，假设n = O（k * log（k））并且基于n（生态系统的大小）和c（单个节点的计算能力）的所有内容是我们使用的完美的模型。



## 解决可伸缩性问题有哪些中等简单但只有部分方法？

许多分片提议（例如，新国立大学Loi Luu等人提出的早期BFT分片提案，Zilliqa中类似思想的最近应用，以及比特币建议的这种Merklix tree1方法）尝试仅进行分片交易处理或仅碎片状态，不触及其他2。这些努力令人钦佩，可能会带来效率的一些提升，但它们遇到的根本问题是它们只能解决两个瓶颈之一。我们希望能够每秒处理10,000多个事务，而无需强制每个节点成为超级计算机或强制每个节点存储数TB的状态数据，这需要一个全面的解决方案，其中状态存储，事务处理甚至是工作负载的工作负载交易下载和重新广播都是跨节点分布的。

特别要注意的是，这需要在P2P级别进行更改，因为广播模型不可扩展，因为它要求每个节点下载并重新广播O（n）数据（每个正在发送的事务），而我们的分散标准假定每个节点只能访问各种O（c）资源。


##那些不试图“分片”任何东西的方法呢？

比特币NG可以通过替代的区块链设计来提高可扩展性，如果节点花费大量的CPU时间来验证块，则可以使网络更加安全。在简单的PoW区块链中，存在很高的集中风险，如果容量增加到超过大约5％的节点CPU时间用于验证块，则会降低共识的安全性; Bitcoin-NG的设计缓解了这个问题。但是，这只能通过大约5-50x3,4的常数因子来增加事务容量的可扩展性，并且不会增加状态的可伸缩性。也就是说，比特币NG风格的方法与分片不是互斥的，两者当然可以同时实现。

基于渠道的策略（闪电网络，Raiden等）可以通过常数因子扩展交易容量，但不能扩展状态存储，并且还具有自己独特的权衡和限制，特别是涉及拒绝服务攻击。通过分片（加上其他技术）进行的链上缩放和通过通道进行的链外缩放可以说是必要的和互补的。

存在使用高级密码术的方法，例如Mimblewimble和基于ZK-SNARK的策略，以解决缩放问题的一个特定部分：初始全节点同步。节点可以验证当前状态合法地遵循历史记录的加密证据，而不是从起源验证整个历史。这些方法确实解决了一个合法的问题，尽管值得注意的是，人们可以依靠加密经济学而不是纯加密技术以更简单的方式解决同一问题 - 请参阅以太坊目前的快速同步和扭曲同步实现。这两种解决方案都无法缓解州规模增长或在线交易处理的限制。



## Plasma，状态通道和其他第2层技术如何适应三难？

如果对Plasma子链发生大规模攻击，则Plasma子链的所有用户都需要退回到根链。如果Plasma有O（N）个用户，那么这将需要O（N）个事务，因此O（N / C）时间来处理所有提款。如果撤销延迟固定在某些D（即天真的实施），那么只要N> C * D，区块链就没有足够的空间来及时处理所有的撤回，因此系统将是不安全的;在这种模式下，等离子体应被视为仅通过（可能很大的）常数因子来提高可扩展性。如果提款延迟是灵活的，那么如果有很多提款，它们会自动延长，那么这意味着随着N的进一步增加，攻击者可以强制每个人的资金被锁定的时间增加，所以等级系统的“安全性”在某种意义上进一步降低，因为扩展的拒绝访问可被视为安全性失败，尽管比完全失去访问权限要轻一些。然而，这是与其他解决方案进行权衡的不同方向，并且可以说是更温和的权衡，因此，为什么等离子体子链仍然是对现状的大幅改进。

国家渠道具有相似的属性，但在多功能性和终结速度之间有不同的权衡。其他第2层技术包括TrueBit执行的离线交互式验证和Raiden，后者是另一个在州渠道上工作的组织。与Casper（第1层）的股权证明也将改善规模 - 它更加分散，不需要能够开采的计算机，这往往集中采矿农场和制度化的采矿池，因为难度增加和国家的规模区块链增加了。

分片不同于状态通道和等离子体，因为周期性公证人被伪随机分配以对归类的有效性进行投票（类似于块，但在阶段1中没有EVM状态转换函数），然后这些归类被接受到主链中在主链上的委员会通过主链上的经销商合同验证投票后。在阶段5（有关详细信息，请参阅路线图），分片与主链紧密耦合，因此如果任何分片或主链无效，则整个网络无效。每种机制之间还存在其他差异，但在较高层次上，等离子，状态通道和Truebit在无限期间内脱链，连接到智能合约的主链，第2层，同时它们可以退回到从主链开放，而分片通过协议内的协议定期链接到主链。

另见Vlad的这些推文。


## 状态的大小，状态历史，密码经济学，哦，我的！在我们继续前进之前定义其中的一些术语！

* 状态：表示系统“当前状态”的一组信息;在最简单的模型中，确定事务是否有效以及事务的影响应该仅取决于状态。状态数据的示例包括比特币中设置的UTXO，以太坊中的余额+随机数+代码+存储以及Namecoin中的域名注册表条目。
历史：自创世以来发生的所有交易的有序列表。在一个简单的模型中，现状应该是起源状态和历史的确定性函数。

* 交易：进入历史的对象。实际上，事务表示某个用户想要进行的操作，并且是加密签名的。在一些系统中，事务被称为blob，以强调这样的事实：在这些系统中，这些对象可能包含任意数据，并且可能并非在所有情况下都表示尝试在协议中执行某些操作。

* 状态转换功能：一种处理状态，应用事务并输出新状态的功能。涉及的计算可能涉及从交易指定的账户中添加和减去余额，验证数字签名和运行合同代码。

* Merkle树：一种加密哈希树结构，可以存储大量数据，其中对每个单独的数据进行身份验证只需要O（log（n））空间和时间。详情请见此处。在以太坊中，每个块的事务集以及状态都保存在Merkle树中，其中树的根被提交到块中。

* Receipt：一个对象，表示事务的效果，该事务不是直接存储在状态中，但是仍然存储在Merkle树中并且被提交到块头或状态中的特殊位置，以便它的存在可以以后可以有效地证明甚至没有所有数据的节点。登录以太坊是收据;在分片模型中，收据用于促进异步交叉分片通信。

* 轻客户端：一种与区块链交互的方式，只需要非常少量（我们会说O（1），虽然O（log（c））在某些情况下也可能是准确的）计算资源，保持跟踪默认情况下，只有链的块头，并通过根据需要询问和验证相关数据的Merkle证据，获取有关交易，状态或收据的任何所需信息。

* 状态根：代表state5的Merkle树的根哈希

以太坊1.0状态树，以及状态根如何适应块结构





## 分片背后的基本思想是什么？

我们将状态和历史分成K = O（n / c）分区，我们称之为“分片”。例如，以太坊上的分片方案可能会将所有以0x00开头的地址放入一个分片，所有地址都以0x01开头进入另一个分片，等等。在最简单的分片形式中，每个分片也有自己的事务历史记录，以及某些shard k中的事务仅限于shard k的状态。一个简单的例子是多资产区块链，其中有K个分片，每个分片存储余额并处理与一个特定资产相关的交易。在更高级的分片形式中，还包括某种形式的交叉分片通信功能，其中一个分片上的事务可以触发其他分片上的事件。

## 分片区块链的基本设计是什么样的？

一种简单的方法如下。为简单起见，此设计仅跟踪数据blob;它不会尝试处理状态转换函数。

存在称为提议者的节点，它接受碎片k上的blob（根据协议，提议者要么选择哪个k，要么随机分配一些k）并创建归类，因此它们也充当整理者，因此作为提议者的代理人并且整理者可以被称为赞助者。排序规则具有排序规则标题，形式为“这是碎片k上的blob排序规则，父排序规则为0x7f1e74，Blob的Merkle根为0x3f98ea”的短消息。每个分片的排序形成一个链，就像传统区块链中的块一样。

还存在称为公证人的节点，其在随机分配的分片中下载归类以确保可用性，并且仅在存在EVM时，通过执行数据来验证归类以确保有效性。这些公证人通过例如每个时期被拖曳到一个新的碎片。随机信标链，在没有EVM的情况下，对整理中数据的可用性进行投票，并且在存在EVM的情况下，还充当执行者并对数据的有效性进行投票。

信标链的随机性源是一些可公开验证的随机函数，例如RANDAO或由BLS聚合签名产生的blockhash。前者是首选，因为有利于可用性而不是一致性，并且不需要诚实/不协调的多数假设（即没有贿赂攻击或串通多数），而概率上需要较低的股权来恢复链，尽管通过使用n-of-n委员会。 N-of-n表示，以三分之三为例：“在全球时钟的每个刻度线上，一个新的提议者和一个新的三人委员会被选为RANDAO信标。为了提出建议通过（提案是与最后承诺相对应的原像），提案需要从委员会获得所有三个签名。“ （资源）。因此，n-of-n意味着委员会中的所有n个（或n个n个）成员必须签署该提案。

然后，委员会还可以检查公证人的这些投票，并决定是否在主链中包含排序规则标题，从而建立与分片中排序规则的交叉链接。其他方可以向委员会，公证人，提名人，验证人（Casper of Stake of Stake）等提出质疑，例如：使用交互式验证游戏，或通过验证有效性证明。

每个人处理的“主链”仍然存在，但是这个主链的作用仅限于存储所有分片的校对头。 shard k的“规范链”是shard k上有效归类的最长链，其所有标题都在规范主链内。

请注意，现在在这样的系统中可以存在几个节点“级别”：

*超级完整节点 - 完全下载每个分片以及主链的每个排序规则，完全验证所有内容。
*顶级节点 - 处理所有主链块，为其提供对所有分片的“轻客户端”访问。
*单分片节点 - 充当顶级节点，但也完全下载并验证它关心的某些特定分片上的每个归类。
* Light节点 - 仅下载和验证主链块的块头;不会处理任何归类头或事务，除非它需要读取某些特定分片状态下的某些特定条目，在这种情况下，它会将Merkle分支下载到该分片的最新归类头，并从那里下载Merkle证明该州的理想价值。


## 这里面临哪些挑战？

* 单一碎片接管攻击 - 如果攻击者接管一个碎片中的大多数公证人或者粉碎者，或者（分别）阻止任何归类获得足够的签名，或者更糟糕的是，提交无效的归类？
* 状态转换执行 - 通常使用随机采样方案来防止单一分片接管攻击，但是此类方案也使得安全人员更难以计算状态根，因为他们无法获得每个分片的最新状态信息。被分配到。我们如何确保轻客户仍能获得有关州的准确信息？
* 欺诈检测 - 如果确实进行了无效的整理或状态声明，节点（包括光节点）如何能够可靠地通知这一点，以便他们可以检测到欺诈并拒绝核对，如果它真的是欺诈性的？
* 交叉分片通信 - 上述设计不支持交叉分片通信。我们如何安全地添加跨分片通信？
* 数据可用性问题 - 作为欺诈检测的一个子集，整理中缺少数据的具体情况如何？
* 超级二次分片 - 在n> c ^ 2的特殊情况下，在上面给出的简单设计中，将有多于O（c）校对头，因此普通节点甚至不能处理顶层块。因此，事务和顶级块头之间需要两个以上的间接级别（即我们需要“分片分片”）。最简单，最好的方法是什么？

但是，事务的影响可能取决于之前在其他分片中发生的事件;一个典型的例子是货币转移，通过首先创建一个“借记”交易来破坏碎片i中的硬币，然后创建一个在碎片j中创建硬币的“信用”交易，指向金钱可以从碎片i移动到碎片j到借记交易创建的收据，作为信用证合法的证明。



## 但CAP定理是否意味着完全安全的分布式系统是不可能的，因此分片是徒劳的？

CAP定理是与分布式共识有关的结果;一个简单的陈述是：“在发生网络分区的情况下，你必须选择一致性或可用性，你不能同时拥有它们”。直观的论点很简单：如果网络分成两半，在一半我发送交易“发送我的10个硬币到A”，在另一个我发送交易“发送我的10个硬币到B”，然后系统不可用，因为一个或两个交易将不会被处理，或者变得不一致，因为网络的一半将看到第一个交易完成，另一半将看到第二个交易完成。注意CAP定理与可伸缩性无关;它适用于多个节点需要就某个值达成一致的任何情况，无论它们同意的数据量如何。所有现有的分散系统都在可用性和一致性之间找到了一些妥协;在这方面，分片不会使任何事情变得更加困难。




## 我们正在运营的安全模型是什么？

有几种竞争模型可以评估区块链设计的安全性：

* 诚实多数（或诚实的绝对多数）：我们假设有一些验证器，并且这些验证器的高达50％（或33％或25％）由攻击者控制，其余验证器诚实地遵循协议。诚实的多数模型可能具有非适应性或自适应对手;如果攻击者可以快速选择验证器的哪一部分设置为“腐败”，则对手是自适应的，如果他们只能提前做出这种选择，则是非自适应的。请注意，对于具有61％诚实假设的公证委员会，诚实多数人的假设可能更高。
* 不协调的多数：我们假设所有验证者在游戏理论意义上都是理性的（除了攻击者，他的动机是以某种方式使网络失败），但不超过一些分数（通常在25％到50％之间）能够协调他们的行动。
*协调选择：我们假设大多数或所有验证器都由同一个演员控制，或完全能够协调他们之间经济上最优的选择。我们可以谈谈实现某些不良结果的联盟（或联盟的利润）的成本。
* 贿赂攻击者模型：我们采用不协调的多数模式，但攻击者不是让攻击者成为参与者之一，而是在协议之外，并且有能力贿赂任何参与者以改变他们的行为。攻击者被建模为拥有预算，这是他们愿意支付的最高金额，我们可以谈论他们的成本，他们最终为破坏协议均衡而支付的金额。

在真实的多数假设下，比特币证明与Eyal和Sirer的自私挖掘修正工作的可靠性高达50％，在未经协调的多数假设下高达约23.21％。在诚实的多数和不协调的多数假设下，Schelling币的稳健性高达50％，在协调选择模型中具有ε（即略高于零）的攻击成本，并且在贿赂攻击者模型中具有P +ε预算要求和ε成本由于P + epsilon攻击。

混合模型也存在;例如，即使在协调选择和贿赂攻击者模型中，通常做出一个诚实的少数人假设，即无论激励如何，某些部分（可能是1-15％）的验证者将采取无私的行为。我们还可以讨论由50-99％的验证人组成的联盟，试图破坏协议或损害其他验证者;例如，在工作证明中，51％的联盟可以通过拒绝包括所有其他矿工的区块来使其收入翻倍。

诚实的多数模式可以说是非常不现实的，并且已经在经验上被证明是错误的 - 请参阅比特币的SPV挖掘叉，以获得一个实际的例子。这证明太多了：例如，诚实的多数模式意味着诚实的矿工愿意自愿焚烧自己的钱，如果这样做会以某种方式惩罚攻击者。不协调的多数假设可能是现实的;还有一个中间模型，其中大多数节点是诚实的但有预算，所以如果它们开始损失太多钱，它们就会关闭。

贿赂攻击者模型在某些情况下被批评为不切实际的对抗性，尽管其支持者认为，如果协议设计时考虑到贿赂攻击者模型，那么它应该能够大规模降低共识的成本，因为51％的攻击成为可以从中恢复的事件。我们将在不协调的多数和贿赂攻击者模型的背景下评估分片。贿赂攻击者模型类似于最大自适应对手模型，除了对手具有额外的权力，它可以从所有节点请求私人信息;这种区别可能是至关重要的，例如Algorand在自适应对手模型下是安全的，但不会贿赂攻击者模型，因为它依赖私人信息进行随机选择。





## 如何在不协调的多数模型中解决单一碎片接管攻击？

总之，随机抽样。为每个分片分配一定数量的公证人（例如150），并且从该样本中获取批准每个分片上的归类的公证人。样本可以半频繁地（例如每12小时一次）或最大频繁地重新洗牌（即，没有真正的独立采样过程，每个块从全局池中为每个分片随机选择公证人）。

抽样可以是明确的，如在选择特定大小的“委员会”的协议中，并要求他们对特定校对的有效性和可用性进行投票，或者它可以是隐含的，如“最长链”协议的情况，其中节点被伪随机分配给建立在特定的整理基础之上，预计至少会对其所构建的整理的N个祖先进行“回调验证”。

结果是，即使在任何给定时间只有少数节点在每个分片上验证和创建块，但在诚实或不协调的多数模型中，安全级别实际上并不比每个单独的节点低得多。节点正在验证和创建块。原因很简单：如果你假设全局集合中有大约67％的诚实绝对多数，并且如果样本的大小是150，那么以99.999％的概率，样本将满足诚实的多数条件。如果假设全局集合中有75％的诚实绝对多数，那么该概率会增加到99.999999998％（有关计算详情，请参阅此处）。

因此，至少在诚实/不协调的多数环境中，我们有：

*分散（每个节点只存储O（c）数据，因为它是O（c）分片中的轻客户端，因此存储O（1）* O（c）= O（c）数据块的数据，以及O（c）对应于当前分配给它的一个或多个分片的最近历史的数据）
*可扩展性（使用O（c）分片，每个分片具有O（c）容量，最大容量为n = O（c ^ 2））
*安全性（攻击者需要控制整个O（n）大小的验证器池的至少~33％才能有机会接管网络）。

在贿赂攻击者模型中（或者在“非常非常自适应的对手”模型中），事情并不那么容易，但我们稍后会讨论这个问题。请注意，由于采样的不完善性，安全阈值确实从50％降低到~30-40％，但这仍然是一个令人惊讶的低安全性损失，可扩展性可提高100-1000倍而不会损失分散性。




## 你如何在工作证明和股权证明中进行抽样？

在证明赌注，这很容易。已经有一个“主动验证器集”在状态中跟踪，并且可以直接从该集合中进行采样。协议内算法运行并为每个分片选择150个验证器，或者每个验证器独立运行一个算法，该算法使用共同的随机源来（可证实地）确定它们在任何给定时间的分片。请注意，抽样分配是“强制性”非常重要;验证器无法选择它们进入的碎片。如果验证者可以选择，那么拥有较少总赌注的攻击者可以将他们的赌注集中在一个碎片上并对其进行攻击，从而消除系统的安全性。

在工作证明中，它更加困难，因为“直接”工作计划证明无法阻止矿工将工作应用于给定的碎片。可以使用文件证明访问形式的工作证明来锁定单个矿工到单个碎片，但很难确保矿工无法快速下载或生成可用于其他碎片的数据，从而规避这样的机制。最着名的方法是通过Dominic Williams发明的一种称为“拼图塔”的技术，矿工首先在一个公共链上进行工作证明，然后将它们引入到一个股份式验证池的证明中，然后验证器池就是如在股权证明案件中那样采样。

一种可能的中间路线可能如下所示。矿工可以花费大量（O（c））量的工作来创建新的“加密身份”。然后，工作证明解决方案的精确值选择他们必须使用哪个碎片进行下一个块。然后，他们可以花费O（1）大小的工作量来创建该碎片上的块，并且该工作证明解决方案的值确定他们可以在下一个工作的碎片，等等8。请注意，所有这些方法都以某种方式证明工作是“有状态的”;这种必要性是至关重要的。



## 如何生成随机抽样的随机性？

首先，重要的是要注意即使随机数生成可被大量利用，这也不是协议的致命缺陷;相反，它只是意味着存在中到高的集权激励。原因在于，由于随机性采样相当大的样本，因此很难将随机性偏差超过一定量。

显示这一点的最简单方法是通过二项分布，如上所述;如果一个人希望避免攻击者破坏大小为N超过50％的样本，并且攻击者拥有全球赌注池的p％，那么攻击者在一轮中获得如此多数的机会是：



这是一个表格，说明在实践中对于N和p的各种值的概率：

<
N = 50N = 100N = 150N = 250
p = 0.4 0.0978 0.0271 0.0082 0.0009
p = 0.33 0.0108 0.0004 1.83 * 10-5 3.98 * 10-8
p = 0.25 0.0001 6.63 * 10-8 4.11 * 10-11 1.81 * 10-17
p = 0.2 2.09 * 10-6 2.14 * 10-11 2.50 * 10-16 3.96 * 10-26
因此，对于N> = 150，任何给定的随机种子将导致有利于攻击者的样本的可能性非常小11,12。从随机性的安全性的角度来看，这意味着攻击者需要在选择随机值时具有非常大的自由度，以便彻底打破采样过程。利益证据随机性中的大多数漏洞都不允许攻击者简单地选择种子;在最坏的情况下，它们会给攻击者很多机会从许多伪随机生成的选项中选择最有利的种子。如果一个人非常担心这个问题，可以简单地将N设置为更大的值，并在计算随机性的过程中添加一个中等硬度的密钥推导函数，这样就需要超过2100个计算步骤才能找到偏向的方法随机性充分。

现在，让我们看看为了获利而不是彻底接管，试图以更小的方式影响随机性的攻击风险。例如，假设存在一种算法，伪随机地从一些非常大的集合中选择1000个验证器（每个验证器获得1美元的奖励），攻击者拥有10％的股份，因此攻击者的平均“诚实”收入为100，并且攻击者可以花费1美元来控制随机性“重新掷骰子”（攻击者可以无限次地执行此操作）。

由于中心极限定理，样本数量的标准差，并且基于数学中其他已知结果，N个随机样本的预期最大值略低于M + S * sqrt（2 * log（N）），其中M是平均值和S是标准偏差。因此，操纵随机性并有效地重新掷骰子（即增加N）的奖励急剧下降，例如，重新试用0次，你的预期奖励是100美元，一次重试是105.5美元，两次是108.5美元，三次是110.3美元，四次是111.6美元，五次是112.6美元，六次是113.5美元。因此，经过五次重审后，它就不值得了。因此，一个拥有10％股权的经济动机的攻击者将（社交浪费）花费5美元来获得13美元的额外收入，净盈余为8美元。

然而，这种逻辑假设一轮重新掷骰子是昂贵的。许多旧的股权证明算法都存在“利害关系”漏洞，其中重新掷骰子只意味着在一台计算机上进行本地计算;具有此漏洞的算法在分片上下文中肯定是不可接受的。较新的算法（参见证明问题常见问题解答中的“验证者选择”部分）具有重新掷骰子的属性，只能通过在块创建过程中自愿放弃一个点来完成，这需要放弃奖励和费用。减轻边际经济动机攻击样本选择影响的最佳方法是找到增加成本的方法。从N轮投票中将成本增加因子sqrt（N）的一种方法是由Iddo Bentov设计的多数位方法。

少数联盟无法利用的另一种随机数生成形式是多米尼克·威廉姆斯研究和倡导的确定性阈值签名方法。这里的策略是使用确定性阈值签名来生成从中选择样本的随机种子。确定性阈值签名具有以下特性：无论给定的一组参与者向算法提供其数据，该值都保证相同，前提是至少有1/3参与者确实参与。这种方法显然不具有经济可利用性，并且完全抵抗所有形式的磨削，但它有几个缺点：

它依赖于更复杂的密码术（特别是椭圆曲线和配对）。其他方法只依赖于普通哈希的随机预言


## 采样频率或多或少会有什么权衡取舍？

选择频率会影响协议的自适应对象如何保持对它们的安全性;例如，如果您认为自适应攻击（例如不诚实的验证者发现他们是同一个样本绑定在一起并勾结）可能会在6小时内发生但不会更少，那么您可以在4小时的采样时间内完成但不是12个小时。这是支持尽快进行抽样的论据。

采样每个区块的主要挑战是重新洗牌带来了非常大的开销。具体来说，验证分片上的块需要知道该分片的状态，因此每次验证器重新洗牌时，验证器都需要下载它们所在的新分片的整个状态。这需要强大的状态大小控制政策（即经济上确保国家规模不会变得太大，无论是通过删除旧账户，限制创建新账户的比率还是两者的组合）和相当长的重新洗牌时间才能很好地运作。

目前，Parity客户端可以在~2-8小时内通过“warp-sync”下载并验证完整的以太坊状态快照，这表明几天但不是更少的重新洗牌是安全的;也许这可以通过通过存储租金缩小州规模来减少，但即使仍然需要很长时间的重组，这可能会使系统容易受到适应性对手的攻击。

但是，有一些方法可以完全避免权衡，在每个分片中选择下一个排序规则的创建者只需几分钟的警告，但不会增加不可能的高状态下载开销。这是通过将状态存储的责任，甚至可能是状态执行，完全转移到整个协作者，而是将角色分配给用户或交互式验证协议来完成的。



##我们可以强制更多的状态保持在用户端，以便可以验证事务而不需要验证器来保存所有状态数据吗？

另见：https：//ethresear.ch/t/the-stateless-client-concept/172

这里的技术往往涉及要求用户存储状态数据并提供Merkle证据以及他们发送的每个事务。事务将与Merkle校正正确执行（或“见证”）一起发送，并且该证明将允许仅具有状态根的节点计算新状态根。这种正确的执行证明将由trie中的对象子集组成，这些对象需要遍历以访问和验证事务必须验证的状态信息。因为Merkle证明大小为O（log（n）），访问常量对象的事务的证明也将是O（log（n））大小。


Merkle树中的对象子集，需要在访问多个状态对象的事务的Merkle证明中提供

以纯粹形式实施该方案有两个缺陷。首先，它引入了O（log（n））开销（实际上为~10-30x），尽管有人可能认为这个O（log（n））开销没有看起来那么糟糕，因为它确保了验证器可以始终简单地将状态数据保存在内存中，因此它永远不需要处理访问硬盘驱动器9的开销。其次，如果事务访问的地址是静态的，则可以很容易地应用它，但如果有问题的地址是动态的，则更难以应用 - 也就是说，如果事务执行的代码是read（f（读取） （x）））其中某些状态读取的地址取决于某些其他状态读取的执行结果。在这种情况下，交易发件人认为交易将在他们发送交易时正在读取的地址可能与当交易被包括在块中时实际读取的地址完全不同，因此Merkle证据可能是insufficient10。

这可以通过访问列表（思考：存储尝试的帐户和子集列表）来解决，它们静态地指定哪些数据事务可以访问，因此当矿工收到与证人的交易时，他们可以确定证人包含所有的事务可能访问或修改的数据。然而，这会损害审查阻力，使攻击的形式与尝试的DAO软分叉相似。


##我们可以拆分数据和执行，这样我们就可以从快速洗牌数据验证中获得安全性，而无需改组执行状态执行的节点的开销吗？

是。我们可以创建一个协议，我们将验证者分成三个不同激励的角色（这样激励不会重叠）：提议者或合作者，a.k.a. prolator，公证人和执行者。扩张者负责简单地建立一系列整理;而公证人则验证排序规则中的数据是否可用。调查员不需要验证任何状态依赖（例如，试图发送ETH的人是否有足够的钱）。执行者采用给定的协调者同意的排序链，然后按顺序执行排序中的事务并计算状态。如果排序规则中包含的任何事务无效，执行程序只需跳过它。这样，验证可用性的验证器可以立即重新洗牌，执行器可以保留在一个分片上。

将有一个轻客户端协议，允许轻客户端根据执行者签署的声明确定状态是什么，但该协议不是简单的多数投票共识。相反，协议是一种与Truebit有一些相似之处的交互式游戏，如果存在很大分歧，那么轻客户端只需执行特定的排序或部分排序。因此，即使分片中90％的执行程序已损坏，轻客户端也可以获得正确的状态视图，从而使执行程序很少被重新洗牌甚至永久特定于分片特征更安全。

选择整理的内容确实需要了解整理的状态，因为这是了解实际支付交易费用的最实用的方法，但这可以通过进一步分离整理者的角色来解决（他们同意历史）和提议者（提出个人整理）并在两类参与者之间创造市场;请看这里有关此问题的更多讨论。然而，根据这一分析，此后发现这种方法存在缺陷。

## SNARK和STARK可以提供帮助吗？

是!可以创建二级协议，其中SNARK，STARK或类似的简洁零知识证明方案用于证明分片链的状态根，并且证明创建者可以为此获得奖励。也就是说，仍然需要分片链实际上同意首先将哪些数据包含在分片链中。



## 我们如何促进交叉分片通信？

最容易满足的方案是，有很多应用程序单独没有太多用户，并且只是偶尔和松散地相互交互;在这种情况下，应用程序可以存在于单独的分片上，并通过收据使用交叉分片通信来相互通信。

这通常涉及将每笔交易分解为“借记”和“贷方”。例如，假设我们有一个交易，其中碎片M上的账户A希望在碎片N上向账户B发送100个硬币。步骤如下：

1.在碎片M上发送交易，其中（i）扣除A的余额100个硬币，以及（ii）创建收据。收据是不直接保存在状态中的对象，但是可以通过Merkle证明验证生成收据的事实。
2.等待包含第一个事务（有时需要等待完成;这取决于系统）。
3.在碎片N上发送交易，其中包括来自（1）的收据的Merkle证明。此交易还会检查碎片N的状态，以确保此收据“未花费”;如果是，那么它将B的余额增加100个硬币，并保存在收据用完的状态。
4.可选地，（3）中的事务还保存收据，该收据然后可以用于对碎片M执行进一步的动作，这些动作取决于原始操作是否成功。


在更复杂的分片形式中，事务在某些情况下可能具有分散在多个分片中的效果，并且还可以同步地请求来自多个分片状态的数据。



##什么是火车和酒店的问题？

以下示例由Andrew Miller提供。假设用户想要购买火车票并预订酒店，并且想要确保操作是原子的 - 要么保留成功，要么两者都不成功。如果火车票和酒店预订应用程序在同一个分片上，这很容易：创建一个尝试同时进行预订的事务，并抛出异常并恢复所有内容，除非两个预留都成功。但是，如果两者都在不同的分片上，那就不那么容易了;即使没有加密经济/权力下放问题，这本质上也是原子数据库交易的问题。

仅使用异步消息，最简单的解决方案是首先预订火车，然后预订酒店，然后一旦预订成功确认两者;预订机制将阻止任何其他人保留（或至少将确保有足够的地点开放以允许所有预订得到确认）一段时间。但是，这意味着该机制依赖于额外的安全性假设：来自一个分片的交叉分片消息可以在某个固定的时间段内包含在另一个分片中。

使用跨分片同步事务，问题更容易，但创建能够进行跨分片原子同步事务的分片解决方案的挑战本身显然是非常重要的;请参阅Vlad Zamfir关于合并块的演讲。

另一种解决方案是让合同本身可以跨越碎片移动;请参阅建议的交叉分片锁定方案以及此提议，其中合约可以从一个分片“拉”到另一个分片，允许通常驻留在不同分片上的两个合同临时移动到同一分片，此时同步操作他们可以发生。


##在贿赂攻击者或协调选择模型中通过随机抽样进行分片的问题是什么？

在贿赂攻击者或协调选择模型中，验证器随机抽样的事实并不重要：无论样本是什么，攻击者都可以贿赂绝大多数样本来做攻击者所喜欢的，或者攻击者控制多数直接采样并指导样品以低成本执行任意操作（确切地说是O（c）成本）。

此时，攻击者有能力对该样本进行51％的攻击。威胁进一步放大，因为存在交叉碎片传染的风险：如果攻击者破坏了碎片的状态，攻击者就可以开始向其他碎片发送无限量的资金并执行其他交叉碎片恶作剧。总而言之，贿赂攻击者或协调选择模型的安全性并不比简单地创建O（c）山寨币好多少。

##我们如何才能改进这一点？

在状态执行的上下文中，我们可以使用非随机抽样多数投票的交互式验证协议，即使90％的参与者有错，也可以给出正确的答案;有关如何完成此操作的示例，请参阅Truebit。对于数据可用性，问题更难，尽管有几种策略可以与多数票一起使用来解决它。

##什么是数据可用性问题，我们如何使用纠删码来解决它？

请参阅https://github.com/ethereum/research/wiki/A-note-on-data-availability-and-erasure-coding


##我们可以通过某种花哨的加密累加器方案来消除解决数据可用性的需要吗？

不。假设存在一种方案，其中存在表示状态（S可能是散列）的对象S以及可以证明存在现有状态对象的各个用户持有的辅助信息（“见证人”）（例如， S是Merkle根，证人是分支，但其他结构如RSA累加器确实存在）。存在一种更新协议，其中一些数据被广播，并且该数据改变S以改变状态的内容，并且还可能改变证人。

假设一些用户具有该状态中的一组N个对象的见证，并且更新了M个对象。在接收到更新信息之后，用户可以检查所有N个对象的新状态，从而查看哪些M被更新。因此，更新信息本身编码至少~M * log（N）比特的信息。因此，每个人为实现M个事务的效果而需要接收的更新信息必须具有O（M）的大小。 14

##所以这意味着我们实际上可以创建可缩放的分片区块链，其中发生任何不良事件的成本与整个验证器集的大小成正比？

有一个微不足道的攻击，攻击者可以随时攻击O（c）资本暂时降低碎片的质量：通过发送高交易费的交易来垃圾邮件，迫使合法用户出价高于你。这种攻击是不可避免的;您可以通过灵活的气体限制进行补偿，您甚至可以尝试“透明分片”方案，尝试根据使用情况自动将节点重新分配到分片，但如果某些特定应用程序不可并行化，Amdahl定律可确保您没有任何内容可以做。在这里打开的攻击（提醒：它只适用于Zamfir模型，而不是诚实/不协调的多数）可以说并不比交易垃圾邮件攻击差。因此，我们已经达到了单个分片的安全性的已知限制，并且没有尝试进一步的价值。



##让我们回过头来。如果我们有即时洗牌，我们真的需要这种复杂性吗？即时重排是否意味着每个分片都直接从全局验证器池中提取验证器，因此它就像区块链一样运行，因此分片实际上不会引入任何新的复杂性？

有点。首先，值得注意的是，即使没有分片，工作证明和简单的股权证明在贿赂攻击者模型中都具有非常低的安全性;在O（n）时间之后，经济意义上的一个区块才真正“最终确定”（好像只有几个区块已经过去，那么更换链条的经济成本就是从区块之前开始双重支出的成本问题）。 Casper通过增加其最终机制解决了这个问题，从而使经济安全边际立即增加到最大值。在一个分片链中，如果我们想要经济最终性，那么我们需要提出一系列推理，为什么验证者愿意在完全基于随机样本的链上做出非常强烈的主张，当验证者本身被说服时贿赂攻击者和协调选择模型可能是真的，因此随机样本可能会被破坏。

##您提到了透明分片。我12岁了，这是什么？

基本上，我们不直接向开发人员公开“shards”的概念，也不会将状态对象永久地分配给特定的分片。相反，该协议具有持续的内置负载平衡过程，可在分片之间移动对象。如果碎片太大或消耗太多气体，它可以分成两半;如果两个碎片变得太小并且经常彼此交谈，它们可以组合在一起;如果所有分片都变得太小，则可以删除一个分片并将其内容移动到其他各个分片等。

想象一下，如果唐纳德特朗普意识到人们在纽约和伦敦之间旅行很多，但是路上有一片海洋，所以他可以拿出剪刀，剪掉海洋，将美国东海岸和西欧粘在一起，然后把它们放在一起。大西洋在南极旁边 - 就像那样。



## 这有什么优点和缺点？

* 开发人员不再需要考虑分片
* 碎片可以手动调整以适应天然气价格的变化，而不是依靠市场机制来提高某些碎片中的天然气价格。
* 不再存在可靠的共同放置的概念：如果将两个合同放入同一个碎片中以便它们可以相互交互，则碎片更改可能最终会将它们分开
* 更多协议复杂性

通过引入“顺序域”的概念可以减轻共置问题，其中契约可以指定它们存在于相同的顺序域中，在这种情况下，它们之间的同步通信将始终是可能的。在此模型中，分片可以被视为一组一起验证的顺序域，并且如果协议确定这样做是有效的，则可以在分片之间重新平衡顺序域。

## 同步交叉分片消息如何工作？

如果您将事务历史记录视为已经解决，并且只是尝试计算状态转换函数，则该过程会变得更加容易。有几种方法;一个相当简单的方法可以描述如下：

事务可以指定它可以操作的一组分片
为了使事务有效，它必须包含在所有这些分片中的相同块高度。
块中的事务必须按其哈希的顺序放置（这确保了规范的执行顺序）
碎片X上的客户端，如果它看到带有分片（X，Y）的事务，则从碎片Y请求Merkle证明，验证（i）碎片Y上是否存在该事务，以及（ii）碎片上的预先状态是什么Y表示事务需要访问的那些数据位。然后它执行事务并提交执行结果。注意，如果在每个块中存在许多具有许多不同“块对”的事务，则该过程可能是非常低效的;因此，简单地要求块来指定姐妹分片可能是最佳的，然后可以在每个块级别更有效地进行计算。这是这种计划如何运作的基础;可以想象更复杂的设计。但是，在进行新设计时，确保低成本拒绝服务攻击无法任意减慢状态计算是非常重要的。



## 半异步消息怎么样？

Vlad Zamfir创建了一个方案，异步消息仍然可以解决“预订火车和酒店”问题。其工作原理如下。状态跟踪最近进行的所有操作，以及任何给定操作（包括交叉分片操作）触发的操作的图形。如果还原操作，则创建一个收据，然后可以使用该收据将该操作的任何影响恢复到其他分片上;那些恢复可能会触发他们自己的恢复等等。该论点是，如果一个偏向系统使得恢复消息的传播速度可以是其他类型消息的两倍，那么在K轮中完成执行的复杂交叉分片事务可以在另一个K轮中完全恢复。

这个计划引入的开销可能没有得到充分的研究;可能存在触发二次执行漏洞的最坏情况。很明显，如果交易的影响彼此更加孤立，那么这种机制的开销就会降低;也许孤立的执行可以通过有利的天然气成本规则来激励。总而言之，这是高级分片更有前途的研究方向之一。


## 什么是保证跨分片调用？

分片的一个挑战是，当进行呼叫时，默认情况下没有硬协议提供的保证，即该呼叫创建的任何异步操作将在任何特定时间范围内进行，甚至根本不进行。相反，由某个一方在目的地分片中发送一个触发收据的交易。对于许多应用程序来说这是可以的，但在某些情况下，由于以下几个原因可能会出现问题：

可能没有明确被激励的单一方触发特定收据。如果交易的发送使许多方受益，则可能存在公共悲剧效应，其中各方试图等待更长时间直到其他人发送交易（即玩“鸡”），或者只是决定发送交易不值得他们单独交易费用。
分片中的天然气价格可能会波动，并且在某些情况下执行操作的前半部分会迫使用户“跟进”，但用户可能不得不以更高的天然气价格结束。 DoS攻击和相关形式的悲伤可能会加剧这种情况。
一些应用程序依赖于交叉分片消息的“延迟”的上限（例如，火车和旅馆示例）。由于缺乏硬性保证，此类应用程序必须具有低效的大安全裕度。
有人可能会尝试建立一个系统，在这个系统中，某些分片中的异步消息会在一些块之后自动触发目标分片中的效果。但是，这要求每个分片上的每个客户端在计算状态转换函数的过程中主动检查所有其他分片，这可能是效率低下的根源。最着名的折衷方法是：当高度为height_a的碎片A中的收据包含在高度为height_b的碎片B中时，如果块高度的差异超过MAX_HEIGHT，则碎片B中的所有验证器都会从height_a + MAX_HEIGHT + 1创建块到height_b - 1会受到惩罚，这种惩罚会成倍增加。这些处罚的一部分被给予验证者，该验证者最终将该块作为奖励。这使状态转换函数保持简单，同时仍然强烈地激励正确的行为。




##等等，但是如果攻击者同时从每个分片发送一个交叉分片调用到shard X怎么办？在数学上不可能及时包含所有这些电话吗？

正确;这是个问题。这是一个建议的解决方案。为了从分片A到分片B进行交叉分片调用，调用者必须预先购买“凝结的分片B气体”（这是通过分片B中的事务完成的，并记录在分片B中）。凝结的碎片B气体具有快速的滞期费率：一旦订购，它每块都会损失其剩余效力的1 / k。然后，碎片A上的事务可以发送凝结的碎片B气体及其创建的收据，并且可以在碎片B上免费使用。碎片B块专门为这些类型的交易分配额外的气体空间。请注意，由于滞期费规则，任何时候可用的给定碎片最多可以有GAS_LIMIT * k的凝结气体，这当然可以在k个区块内填充（事实上，由于滞期费，更快，但我们可能由于恶意验证器需要这个松弛的空间）。如果太多验证者恶意未能包含收据，我们可以通过豁免填写其区块“收据空间”的验证员尽可能多的收据，从最旧的收据开始，使处罚更公平。

在这种预购机制下，想要执行交叉分片操作的用户将首先预先购买操作将进入的所有分片的天然气，过度购买以考虑滞期费。如果操作将创建触发在碎片B中消耗100000气体的操作的收据，则用户将预先购买100000 * e（即271818）碎片-B凝结气体。如果该操作又将在碎片C中消耗100000个气体（即两个间接水平），则用户需要预先购买100000 * e ^ 2（即738906）碎片C凝结气体。请注意，一旦确认购买并且用户开始主要操作，用户可以确信他们将不受天然气价格市场变化的影响，除非验证人自愿从收到的非包含性罚款中损失大量资金。



##凝固气体？这听起来不仅仅是跨分片操作，还有可靠的分片内调度

确实;你可以购买凝结的碎片A碎片A中的气体，并从碎片A发送保证的交叉碎片调用到它自己。虽然注意到该方案仅支持在非常短的时间间隔进行调度，并且调度对于块不是精确的;它只能保证在一段时间内发生。

##是否有保证的调度，包括分片内和交叉分片，有助于防止大多数共谋试图审查交易？

是。如果用户未能获得事务，因为串联验证器正在过滤事务并且不接受包含它的任何块，则用户可以发送一系列消息，这些消息触发一系列保证的预定消息，最后一个消息重建事务在EVM内部并执行它。如果不彻底地关闭保证的调度功能并且极大地限制整个协议，则实际上不可能防止这种规避技术，因此恶意验证器将不能容易地执行。



##分片区块链能否更好地处理网络分区？

本文档中描述的方案与非分片区块链相比没有任何改进;实际上，每个分片最终会在分区的两边都有一些节点。有人呼吁（例如来自IPFS的Juan Benet）建立可扩展的网络，其具体目标是网络可以根据需要分成碎片，从而在网络分区条件下尽可能地继续运行，但是在制作这个网络时存在一些非常重要的加密经济挑战。工作得很好。

一个主要的挑战是，如果我们想要进行基于位置的分片，以便地理网络分区最小程度地阻碍分片内部内聚（具有非常低的分片内延迟的副作用，因此非常快的分片内时间段），那么我们需要有一种方法让验证者选择他们参与的分片。这很危险，因为它允许在诚实/不协调的多数模型中进行更大类别的攻击，因此在Zamfir模型中具有更高悲伤因素的更便宜的攻击。通过随机抽样提高地理分区安全性和分片效率是两个根本不同的事情。

其次，需要更多思考如何组织应用程序。如上所述，分片区块链中的可能模型是每个“应用”在某个分片上（至少对于小规模应用）;但是，如果我们希望应用程序本身具有分区抗性，则意味着所有应用程序都需要在某种程度上进行交叉分片。

解决此问题的一种可能途径是创建一个提供两种分片的平台 - 一些分片将是随机采样的更高安全性的“全局”分片，而其他分片则是具有属性的低安全性“本地”分片例如超快的封锁时间和更便宜的交易费用。非常低安全性的分片甚至可以用于数据发布和消息传递。




##推动缩放超过n = O（c ^ 2）的独特挑战是什么？

有几个注意事项。首先，需要将算法从两层算法转换为可堆叠的n层算法;这是可能的，但很复杂。第二，n / c（即网络的总计算负载与一个节点的容量之间的比率）是恰好接近两个常数的值：首先，如果以块为单位测量，则是几个小时的时间跨度，其中是一个可接受的“最大安全确认时间”，第二，奖励和存款之间的比率（早期计算表明卡斯珀的32 ETH存款规模和0.05 ETH区块奖励）。后者的结果是，如果对碎片的奖励和惩罚升级为验证者存款的规模，则继续攻击碎片的成本将为O（n）。

超过c ^ 2可能需要进一步削弱系统可以提供的安全保障类型，并允许攻击者以特定方式以中等成本长时间攻击单个分片，尽管仍然可以防止无效状态从最终确定并防止最终状态被还原，除非攻击者愿意支付O（n）成本。然而，奖励很大 - 超级二次分片的区块链可以用作几乎所有分散应用的通用工具，并且可以维持交易费用，使其几乎免费使用。

##异构分片怎么样？

抽象执行引擎或允许多个执行引擎存在导致能够为每个分片具有不同的执行引擎。由于Casper CBC能够探索完整的权衡三角形，因此可以将每个分片的共识引擎的参数改变为三角形的任何点。然而，CBC Casper还没有实现，异构分片只不过是现阶段的一个想法;尚未设计或实施其工作方式的具体细节。一些分片可以被优化以具有快速终结性和高吞吐量，这对于诸如EFTPOS事务的应用是重要的，而可能大多数分片的最终性，吞吐量和分散性（验证节点的数量）以及应用程序中的每一个都可以具有中等或合理的量。容易出现高故障率并因此需要高安全性，例如洪流网络，像Proton邮件这样的隐私聚焦电子邮件等，可以优化高分散性，低终端性和高吞吐量等。另见https//twitter.com/VladZamfir/status/932320997021171712和https://ethresear.ch/t/heterogeneous-sharding/1979/2。



##脚注

1. Merklix树== Merkle Patricia树

新加坡国立大学的后来提案确实设法破坏国家;他们通过我在本文档后面部分描述的收据和状态压缩技术来做到这一点。 （这是Vitalik Buterin写的这个Wiki的创建者。）

这里有保守的理由。特别要注意的是，如果攻击者提出处理时间与块空间开销（字节，气体等）之间的比例远高于平时的最坏情况交易，则系统将经历非常低的性能，因此安全系数有必要考虑到这种可能性。在传统的区块链中，块处理仅需要约1-5％的块时间，这一事实具有防止集中风险的主要作用，但却具有防止拒绝服务风险的双重职责。在比特币的特定情况下，其当前最坏情况下已知的二次执行漏洞可能会将目前的任何扩展限制为~5-10x，而在以太坊的情况下，所有已知的漏洞在拒绝后被删除或已被删除 - 服务攻击，仍存在进一步差异的风险，特别是在较小规模上。在比特币NG中，对前者的需求被删除了，但对后者的需求仍然存在。

4.谨慎的另一个原因是增加状态大小对应于吞吐量降低，因为节点会发现将状态数据保存在RAM中越来越难，因此需要越来越多的磁盘访问，而数据库通常具有O（ log（n））访问时间，访问时间越长越长。这是上一次以太坊拒绝服务攻击的一个重要教训，它通过创建空帐户使状态膨胀~10 GB，从而通过强制进一步的状态访问来阻止磁盘而不是RAM来间接减慢处理速度。

5.在分片区块链中，可能不一定对单个全局状态存在锁定共识，因此协议从不要求节点尝试计算全局状态根;事实上，在后面部分介绍的协议中，每个分片都有自己的状态，并且对于每个分片，都有一种机制用于提交该分片的状态根，这表示该分片的状态

6. #MEGA

7.如果不可扩展的区块链升级为可扩展区块链，则作者建议的路径是旧链的状态应该简单地成为新链中的单个分片。

8.为确保安全，必须满足一些其他条件;特别是，工作证明必须是非外包的，以防止攻击者确定哪些其他矿工的身份可用于某些特定的碎片和采矿。


9.最近的以太坊拒绝服务攻击证明，硬盘访问是区块链可扩展性的主要瓶颈。

10.您可以问：为什么验证员不能及时获取Merkle样张？答：因为这样做是一个~100-1000ms的往返，并且在那段时间内执行整个复杂的交易可能会让人望而却步。

11.一种混合解决方案将小样本的正常情况效率与较大样本的更强健性相结合，是一种多层抽样方案：在50个节点之间达成共识，要求80％同意向前推进，然后只有未能达成共识，然后回到250节点样本。具有80％阈值的N = 50即使对于p = 0.4的攻击者也只有8.92 * 10-9的失败率，因此在诚实或不协调的多数模型下这根本不会损害安全性。

12.给出的概率是一个单一的碎片;然而，随机种子影响O（c）分片，攻击者可能会接管其中任何一个。如果我们想同时查看O（c）分片，那么有两种情况。首先，如果磨削过程受到计算限制，那么这个事实根本不会改变微积分，因为即使现在每轮都有O（c）成功的机会，检查成功需要花费O（c）倍的工作量。其次，如果磨削过程在经济上有限，那么这确实需要更高的安全系数（将N增加10到20就足够了）尽管重要的是要注意攻击者在以利润为动机的操纵攻击中的目标是在任何情况下都增加他们对所有分片的参与，因此我们已经在调查。

13.参见Parity的Polkadotpaper，了解他们的“渔民”概念是如何运作的。有关Polkadot的最新信息和代码，请参阅此处。

14.感谢Justin Drake将我指向加密累加器，以及本文给出了次线性批处理不可能性的论点。



另请参见此主题：https：//ethresear.ch/t/accumulators-scalability-of-utxo-blockchains-and-data-availability/176


